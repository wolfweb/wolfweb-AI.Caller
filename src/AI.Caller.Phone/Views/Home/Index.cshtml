@using AI.Caller.Phone.Entities
@*
    For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
*@
@model IEnumerable<Contact>

@{
    ViewData["Title"] = "Phone";
}

<div class="container mt-4">
    <div class="row">
        <!-- 左侧通讯录 -->
        <div class="col-md-4">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">
                        <i class="bi bi-person-lines-fill"></i> 通讯录
                    </h5>
                </div>
                <div class="card-body p-0">
                    <div class="list-group list-group-flush" id="contactsList">
                        @if (Model != null && Model.Any())
                        {
                            @foreach (var contact in Model)
                            {
                                <button type="button" class="list-group-item list-group-item-action contact-item" 
                                        data-name="@contact.Name" data-phone="@contact.PhoneNumber">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div>
                                            <i class="bi bi-person-circle text-primary me-2"></i>
                                            <span class="contact-name">@contact.Name</span>
                                        </div>
                                        <span class="badge bg-light text-dark">@contact.PhoneNumber</span>
                                    </div>
                                </button>
                            }
                        }
                        else
                        {
                            <div class="list-group-item text-center text-muted py-4">
                                <i class="bi bi-info-circle"></i> 没有联系人
                                <div class="mt-2">
                                    <a asp-controller="Account" asp-action="AddContact" class="btn btn-sm btn-outline-primary">
                                        <i class="bi bi-plus-circle"></i> 添加联系人
                                    </a>
                                </div>
                            </div>
                        }
                    </div>
                </div>
                <div class="card-footer text-center">
                    <a asp-controller="Account" asp-action="ManageContacts" class="btn btn-outline-primary btn-sm">
                        <i class="bi bi-gear"></i> 管理通讯录
                    </a>
                </div>
            </div>
        </div>

        <!-- 右侧拨号器 -->
        <div class="col-md-8">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">
                        <i class="bi bi-telephone"></i> 拨号器
                    </h5>
                </div>
                <div class="card-body">
                    <!-- 音频元素 -->
                    <audio id="remoteAudio" autoplay class="d-none"></audio>
                    
                    <!-- 显示当前状态 -->
                    <div class="alert mb-4" id="statusAlert">
                        <span id="status">未连接</span>
                    </div>
                    
                    <!-- 输入框和拨号按钮 -->
                    <div class="input-group mb-4">
                        <span class="input-group-text"><i class="bi bi-telephone"></i></span>
                        <input type="text" id="destination" class="form-control form-control-lg" 
                               placeholder="输入电话号码或选择联系人" />
                        <button id="callButton" class="btn btn-success">
                            <i class="bi bi-telephone-fill"></i> 拨打
                        </button>
                        <button id="answerButton" class="btn btn-primary d-none">
                            <i class="bi bi-telephone-inbound-fill"></i> 接听
                        </button>
                        <button id="hangupButton" class="btn btn-danger d-none">
                            <i class="bi bi-telephone-x-fill"></i> 挂断
                        </button>
                    </div>
                    
                    <!-- 拨号盘 -->
                    <div class="dialpad mb-3">
                        <div class="row g-2 mb-2">
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="1">1</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="2">2</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="3">3</button></div>
                        </div>
                        <div class="row g-2 mb-2">
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="4">4</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="5">5</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="6">6</button></div>
                        </div>
                        <div class="row g-2 mb-2">
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="7">7</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="8">8</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="9">9</button></div>
                        </div>
                        <div class="row g-2">
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="*">*</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="0">0</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="#">#</button></div>
                        </div>
                    </div>
                    
                    <!-- 通话信息 -->
                    <div class="call-info d-none" id="callInfo">
                        <div class="text-center mb-3">
                            <div class="display-1 text-primary">
                                <i class="bi bi-person-circle"></i>
                            </div>
                            <h3 id="callerName">未知联系人</h3>
                            <p id="callerNumber" class="text-muted"></p>
                        </div>
                        <div class="d-flex justify-content-center">
                            <div id="callTimer" class="badge bg-success p-2 fs-6">00:00</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <script src="~/js/ui-integration.js"></script>
    <script src="~/js/error-recovery.js"></script>
    <script src="~/js/hangup-handler.js"></script>
    <script src="~/js/integration-tests.js"></script>
    <script src="~/js/hangup-test.js"></script>
    <script>
        // 获取DOM元素
        const destinationInput = document.getElementById('destination');
        const callButton = document.getElementById('callButton');
        const answerButton = document.getElementById('answerButton');
        const hangupButton = document.getElementById('hangupButton');
        const statusDiv = document.getElementById('status');
        const statusAlert = document.getElementById('statusAlert');
        const callerName = document.getElementById('callerName');
        const callerNumber = document.getElementById('callerNumber');
        const callInfo = document.getElementById('callInfo');
        const callTimer = document.getElementById('callTimer');
        const remoteAudio = document.getElementById('remoteAudio');
        let pc, localStream, signalRConnection, hangupHandler;

        // Call State Management
        const CallState = {
            IDLE: 'IDLE',
            OUTGOING: 'OUTGOING',
            INCOMING: 'INCOMING',
            CONNECTED: 'CONNECTED',
            ENDING: 'ENDING'
        };

        const BUTTON_STATES = {
            IDLE: { call: true, answer: false, hangup: false },
            OUTGOING: { call: false, answer: false, hangup: true },
            INCOMING: { call: false, answer: true, hangup: false },
            CONNECTED: { call: false, answer: false, hangup: true },
            ENDING: { call: false, answer: false, hangup: false }
        };

        class CallStateManager {
            constructor() {
                this.currentState = CallState.IDLE;
                this.isTransitioning = false;
                this.buttons = {
                    call: callButton,
                    answer: answerButton,
                    hangup: hangupButton
                };
                
                // Initialize to idle state
                this.updateButtonVisibility();
                console.log('CallStateManager initialized in IDLE state');
            }

            setState(newState) {
                if (this.isTransitioning) {
                    console.warn(`State transition blocked: already transitioning from ${this.currentState}`);
                    return false;
                }

                if (!CallState[newState]) {
                    console.error(`Invalid state: ${newState}. Falling back to IDLE.`);
                    newState = CallState.IDLE;
                }

                const oldState = this.currentState;
                if (oldState === newState) {
                    console.log(`State unchanged: ${newState}`);
                    return true;
                }

                console.log(`State transition: ${oldState} → ${newState}`);
                
                this.isTransitioning = true;
                this.currentState = newState;
                
                try {
                    this.updateButtonVisibility();
                    console.log(`State successfully changed to: ${newState}`);
                    return true;
                } catch (error) {
                    console.error(`Error during state transition to ${newState}:`, error);
                    this.currentState = CallState.IDLE;
                    this.updateButtonVisibility();
                    return false;
                } finally {
                    this.isTransitioning = false;
                }
            }

            updateButtonVisibility() {
                const config = BUTTON_STATES[this.currentState];
                if (!config) {
                    console.error(`No button configuration for state: ${this.currentState}`);
                    return;
                }

                try {
                    // Update call button
                    if (this.buttons.call) {
                        if (config.call) {
                            this.showButton(this.buttons.call);
                        } else {
                            this.hideButton(this.buttons.call);
                        }
                    }

                    // Update answer button
                    if (this.buttons.answer) {
                        if (config.answer) {
                            this.showButton(this.buttons.answer);
                        } else {
                            this.hideButton(this.buttons.answer);
                        }
                    }

                    // Update hangup button
                    if (this.buttons.hangup) {
                        if (config.hangup) {
                            this.showButton(this.buttons.hangup);
                        } else {
                            this.hideButton(this.buttons.hangup);
                        }
                    }

                    console.log(`Button visibility updated for state: ${this.currentState}`, config);
                } catch (error) {
                    console.error('Error updating button visibility:', error);
                }
            }

            showButton(button) {
                if (!button) {
                    console.warn('Cannot show button: button element is null or undefined');
                    return;
                }
                try {
                    button.classList.remove('d-none');
                    button.disabled = false;
                } catch (error) {
                    console.error('Error showing button:', error);
                }
            }

            hideButton(button) {
                if (!button) {
                    console.warn('Cannot hide button: button element is null or undefined');
                    return;
                }
                try {
                    button.classList.add('d-none');
                    button.disabled = true;
                } catch (error) {
                    console.error('Error hiding button:', error);
                }
            }

            resetToIdle() {
                console.log('Resetting to IDLE state');
                this.setState(CallState.IDLE);
            }

            getCurrentState() {
                return this.currentState;
            }
        }

        // Initialize the call state manager
        let callStateManager;
        
        // 调试函数：检查当前状态
        window.debugCallState = function() {
            console.log('=== 通话状态调试信息 ===');
            console.log('CallStateManager状态:', callStateManager ? callStateManager.getCurrentState() : '未初始化');
            console.log('拨号按钮状态:', {
                disabled: callButton.disabled,
                hidden: callButton.classList.contains('d-none'),
                classes: callButton.className
            });
            console.log('挂断按钮状态:', {
                disabled: hangupButton.disabled,
                hidden: hangupButton.classList.contains('d-none'),
                classes: hangupButton.className
            });
            console.log('接听按钮状态:', {
                disabled: answerButton.disabled,
                hidden: answerButton.classList.contains('d-none'),
                classes: answerButton.className
            });
            console.log('输入框状态:', {
                disabled: destinationInput.disabled,
                value: destinationInput.value
            });
            console.log('HangupHandler状态:', window.hangupHandler ? {
                isHangingUp: window.hangupHandler.isCurrentlyHangingUp()
            } : '未初始化');
            console.log('=== 调试信息结束 ===');
        };

        // Test functions for validation (can be called from browser console)
        window.testCallStateManager = {
            testIdleState: function() {
                console.log('Testing IDLE state...');
                callStateManager.setState(CallState.IDLE);
                const callVisible = !callButton.classList.contains('d-none');
                const answerHidden = answerButton.classList.contains('d-none');
                const hangupHidden = hangupButton.classList.contains('d-none');
                console.log(`IDLE state test: Call visible: ${callVisible}, Answer hidden: ${answerHidden}, Hangup hidden: ${hangupHidden}`);
                return callVisible && answerHidden && hangupHidden;
            },
            
            testOutgoingState: function() {
                console.log('Testing OUTGOING state...');
                callStateManager.setState(CallState.OUTGOING);
                const callHidden = callButton.classList.contains('d-none');
                const answerHidden = answerButton.classList.contains('d-none');
                const hangupVisible = !hangupButton.classList.contains('d-none');
                console.log(`OUTGOING state test: Call hidden: ${callHidden}, Answer hidden: ${answerHidden}, Hangup visible: ${hangupVisible}`);
                return callHidden && answerHidden && hangupVisible;
            },
            
            testIncomingState: function() {
                console.log('Testing INCOMING state...');
                callStateManager.setState(CallState.INCOMING);
                const callHidden = callButton.classList.contains('d-none');
                const answerVisible = !answerButton.classList.contains('d-none');
                const hangupHidden = hangupButton.classList.contains('d-none');
                console.log(`INCOMING state test: Call hidden: ${callHidden}, Answer visible: ${answerVisible}, Hangup hidden: ${hangupHidden}`);
                return callHidden && answerVisible && hangupHidden;
            },
            
            testConnectedState: function() {
                console.log('Testing CONNECTED state...');
                callStateManager.setState(CallState.CONNECTED);
                const callHidden = callButton.classList.contains('d-none');
                const answerHidden = answerButton.classList.contains('d-none');
                const hangupVisible = !hangupButton.classList.contains('d-none');
                console.log(`CONNECTED state test: Call hidden: ${callHidden}, Answer hidden: ${answerHidden}, Hangup visible: ${hangupVisible}`);
                return callHidden && answerHidden && hangupVisible;
            },
            
            testAllStates: function() {
                console.log('Running all state tests...');
                const results = {
                    idle: this.testIdleState(),
                    outgoing: this.testOutgoingState(),
                    incoming: this.testIncomingState(),
                    connected: this.testConnectedState()
                };
                
                const allPassed = Object.values(results).every(result => result);
                console.log('Test results:', results);
                console.log(`All tests ${allPassed ? 'PASSED' : 'FAILED'}`);
                
                // Reset to idle state after testing
                callStateManager.setState(CallState.IDLE);
                return results;
            },
            
            getCurrentState: function() {
                return callStateManager.getCurrentState();
            }
        };

        // 使用公共 STUN 服务器
        const iceServers = [{ urls: 'stun:stun.sipsorcery.com' }];
        let callTimerInterval;
        let callStartTime;
        
        signalRConnection = new signalR.HubConnectionBuilder()        
        .withUrl("/webrtc")
		.configureLogging(signalR.LogLevel.Debug)
        .build();

        signalRConnection.on("signalRConnection", function(msg){
            console.log(msg);
        });

        signalRConnection.on("inCalling", function(x){
            console.log("Incoming call received:", x);
            callerName.innerHTML = x.caller;
            callStateManager.setState(CallState.INCOMING);
            
            try {
                // 健壮的SDP offer处理
                let offerObj;
                if (typeof x.offerSdp === 'string') {
                    offerObj = JSON.parse(x.offerSdp);
                } else if (typeof x.offerSdp === 'object') {
                    offerObj = x.offerSdp;
                } else {
                    console.error("Invalid offer SDP type:", typeof x.offerSdp);
                    updateStatus('来电数据格式错误', 'danger');
                    return;
                }
                
                answerButton.attributes['data-offer'] = offerObj;
                console.log("Offer SDP processed:", offerObj);
            } catch (parseError) {
                console.error("Error parsing offer SDP:", parseError);
                console.error("Original offer data:", x.offerSdp);
                updateStatus('来电数据解析失败', 'danger');
                return;
            }
            
            showCallInfo(true);
            startCallTimer();
        });

        signalRConnection.on("answered", function(){
            updateStatus('通话已接听', 'success');
            callStateManager.setState(CallState.CONNECTED);
            showCallInfo(false);
            stopCallTimer();
            startCallTimer();
            showCallInfo(true);

            signalRConnection.invoke("GetSecureContextState").then(isSecure=>{
                if(!isSecure){
                    updateStatus('当前连接不安全，通话质量可能受影响', 'warning');
                }else{
                    updateStatus('安全链接通话中...', 'info');
                }
            });
        });

        signalRConnection.on("callTimeout", function(){
            updateStatus('拨打超时', 'warning');
            callStateManager.resetToIdle();
            showCallInfo(false);
            stopCallTimer();
        });

        signalRConnection.on("sdpAnswered", function(answerDesc){
            console.log("SDP Answer received from server:", answerDesc, "Type:", typeof answerDesc);
            if (pc) {
                try {
                    // 健壮的SDP处理
                    let sdpObj;
                    if (typeof answerDesc === 'string') {
                        sdpObj = JSON.parse(answerDesc);
                    } else if (typeof answerDesc === 'object') {
                        sdpObj = answerDesc;
                    } else {
                        console.error("Invalid SDP answer type:", typeof answerDesc);
                        return;
                    }
                    
                    console.log("Processing SDP answer:", sdpObj);
                    
                    pc.setRemoteDescription(sdpObj).then(() => {
                        console.log("Remote description set successfully");
                    }).catch(error => {
                        console.error("Error setting remote description:", error);
                        console.error("SDP data:", sdpObj);
                    });
                } catch (parseError) {
                    console.error("Error parsing SDP answer:", parseError);
                    console.error("Original SDP data:", answerDesc);
                }
			}
        });

        signalRConnection.on("receiveIceCandidate",function(candidate){
            if (pc && candidate) {
                console.log("Adding ICE candidate from server:", candidate, pc);
                pc.addIceCandidate(typeof candidate == "string" ? JSON.parse(candidate) : candidate).then(()=>{
                    console.log("add IceCandidate successfully");
                }).catch(error=>{
                    console.error("Error add IceCandidate", error);
                });
            }
        });

        // 监控网络状态变化
        window.addEventListener('online', () => {
            updateStatus('网络已恢复连接', 'success');
            setTimeout(() => {
                updateStatus('就绪', 'success');
            }, 3000);
        });
        
        window.addEventListener('offline', () => { 
            updateStatus('网络已断开，通话可能受到影响', 'danger');
            // Reset to idle state on network disconnection
            if (callStateManager) {
                callStateManager.resetToIdle();
            }
        });
                
        // 监控页面关闭事件，尝试在页面关闭前挂断通话
        window.addEventListener('beforeunload', (event) => {
            //todo: 
        });
                
        // 检查浏览器是否支持WebRTC
        function checkWebRTCSupport() {
            if (!window.RTCPeerConnection) {
                updateStatus('您的浏览器不支持WebRTC，请使用Chrome、Firefox、Edge或Safari的最新版本', 'danger');
                callButton.disabled = true;
                return false;
            }
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateStatus('您的浏览器可能不完全支持音频功能，通话质量可能受影响', 'warning');
            }
            
            return true;
        }
        
        // 检查网络连接状态
        function checkNetworkConnection() {
            if (!navigator.onLine) {
                updateStatus('网络连接不可用，请检查您的网络设置', 'danger');
                return false;
            }
            return true;
        }
        
        async function createPeerConnection(isCaller, remoteSdp) { 
            pc = new RTCPeerConnection(null);
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            pc.ontrack = evt => remoteAudio.srcObject = evt.streams[0];

            pc.onicecandidate = async evt => {
                if (evt.candidate) {
                    console.log("新ICE候选者:", evt.candidate);
                    try {
                        // 发送ICE候选者对象（不需要JSON.stringify，SignalR会自动处理）
                        await signalRConnection.invoke("SendIceCandidateAsync", evt.candidate);
                        console.log("ICE候选者发送成功");
                    } catch (error) {
                        console.error("发送ICE候选者失败:", error);
                    }
                } 
            };

            pc.onicegatheringstatechange = () => console.log("onicegatheringstatechange: " + pc.iceGatheringState);
            pc.oniceconnectionstatechange = () => console.log("oniceconnectionstatechange: " + pc.iceConnectionState);
            pc.onsignalingstatechange = () => console.log("onsignalingstatechange: " + pc.signalingState);
            pc.onconnectionstatechange = () => console.log("onconnectionstatechange: " + pc.connectionState);

            if(isCaller){
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                return pc.localDescription;
            }else{
                await pc.setRemoteDescription(remoteSdp);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                return pc.localDescription;
            }            
        }

        // 获取并选择最佳音频设备
        async function selectOptimalAudioDevices() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                return false;
            }
            
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                // 获取音频输入设备（麦克风）
                const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                console.log(`找到 ${audioInputDevices.length} 个麦克风设备`);
                
                // 获取音频输出设备（扬声器）
                const audioOutputDevices = devices.filter(device => device.kind === 'audiooutput');
                console.log(`找到 ${audioOutputDevices.length} 个扬声器设备`);
                
                // 如果有多个麦克风，尝试选择最佳麦克风（通常是非默认设备，如耳机麦克风）
                let preferredMicrophoneId = '';
                if (audioInputDevices.length > 1) {
                    // 查找非默认设备，通常是耳机或外接麦克风
                    const nonDefaultMicrophone = audioInputDevices.find(device => 
                        !device.deviceId.includes('default') && 
                        !device.label.toLowerCase().includes('default'));
                    
                    if (nonDefaultMicrophone) {
                        preferredMicrophoneId = nonDefaultMicrophone.deviceId;
                        console.log('选择非默认麦克风:', nonDefaultMicrophone.label);
                    }
                } else if (audioInputDevices.length === 1) {
                    preferredMicrophoneId = audioInputDevices[0].deviceId;
                    console.log('使用唯一可用麦克风:', audioInputDevices[0].label || '未命名设备');
                }
                
                // 如果有多个扬声器，尝试选择最佳扬声器（通常是非默认设备，如耳机）
                let preferredSpeakerId = '';
                if (audioOutputDevices.length > 1) {
                    // 查找非默认设备，通常是耳机或外接扬声器
                    const nonDefaultSpeaker = audioOutputDevices.find(device => 
                        !device.deviceId.includes('default') && 
                        !device.label.toLowerCase().includes('default'));
                    
                    if (nonDefaultSpeaker) {
                        preferredSpeakerId = nonDefaultSpeaker.deviceId;
                        console.log('选择非默认扬声器:', nonDefaultSpeaker.label);
                    }
                } else if (audioOutputDevices.length === 1) {
                    preferredSpeakerId = audioOutputDevices[0].deviceId;
                    console.log('使用唯一可用扬声器:', audioOutputDevices[0].label || '未命名设备');
                }
                
                // 如果支持，设置音频输出设备
                if (preferredSpeakerId && typeof remoteAudio.setSinkId === 'function') {
                    try {
                        await remoteAudio.setSinkId(preferredSpeakerId);
                        console.log('已设置音频输出设备');
                    } catch (sinkIdError) {
                        console.warn('设置音频输出设备失败:', sinkIdError);
                    }
                }
                
                return {
                    preferredMicrophoneId,
                    preferredSpeakerId,
                    audioInputDevices,
                    audioOutputDevices
                };
            } catch (error) {
                console.error('枚举音频设备失败:', error);
                return false;
            }
        }
        
        // 初始化检查函数
        async function initializeChecks() {
            if (!checkWebRTCSupport()) {
                return false;
            }
            
            if (!checkNetworkConnection()) {
                return false;
            }
            try {
                const hasPermission = await checkMicrophonePermission();
                if (!hasPermission) {
                    updateStatus('未获得麦克风权限，通话功能可能受限', 'warning');
                } else {
                    const deviceInfo = await selectOptimalAudioDevices();
                    if (deviceInfo) {
                        window.preferredAudioDevices = deviceInfo;
                    }
                }
            } catch (error) {
                updateStatus('无法检查麦克风权限，通话功能可能受限', 'warning');
            }
            setupGlobalErrorHandling();

            await signalRConnection.start();
            
            // 初始化挂断处理器
            const uiElements = {
                hangupButton: hangupButton,
                statusAlert: statusAlert,
                callInfo: callInfo,
                updateStatus: updateStatus,
                showCallInfo: showCallInfo,
                clearCallUI: clearCallUI
            };
            
            hangupHandler = new HangupHandler(signalRConnection, uiElements, callStateManager);
            
            // 设置挂断处理器的事件监听
            document.addEventListener('callEnded', (event) => {
                console.log('收到通话结束事件:', event.detail);
                // HangupHandler已经处理了状态重置和UI清理，这里只需要确保没有遗漏
                showCallInfo(false);
                stopCallTimer();
                console.log('通话结束事件处理完成');
            });
            
            document.addEventListener('remoteHangup', (event) => {
                console.log('收到对方挂断事件:', event.detail);
                // HangupHandler已经处理了状态重置和UI清理，这里只需要确保没有遗漏
                showCallInfo(false);
                stopCallTimer();
                console.log('对方挂断事件处理完成');
            });

            localStream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
            
            return true;
        }
        
        // 设置全局错误处理
        function setupGlobalErrorHandling() {
            // 处理未捕获的JavaScript错误
            window.addEventListener('error', (event) => {
                console.error('未捕获的错误:', event.error || event.message);
                                
                // 防止错误对用户造成困扰
                event.preventDefault();
                return true;
            });
            
            // 处理未处理的Promise拒绝
            window.addEventListener('unhandledrejection', (event) => {
                console.error('未处理的Promise拒绝:', event.reason);
                                
                // 防止错误对用户造成困扰
                event.preventDefault();
                return true;
            });
            
            // 监听设备变化事件
            if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) {
                navigator.mediaDevices.addEventListener('devicechange', handleDeviceChange);
                console.log('设备变化监听已设置');
            }
            
            console.log('全局错误处理已设置');
        }
        
        // 处理设备变化事件
        async function handleDeviceChange() {
            console.log('检测到媒体设备变化');
            
            try {
                // 获取可用的音频设备
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                const audioOutputDevices = devices.filter(device => device.kind === 'audiooutput');
                
                console.log('可用音频输入设备:', audioInputDevices.length);
                console.log('可用音频输出设备:', audioOutputDevices.length);                
            } catch (error) {
                console.error('获取媒体设备信息时出错:', error);
            }
        }

        // 检查麦克风权限
        async function checkMicrophonePermission() {
            try {
                console.log('检查麦克风权限');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // 获取权限后立即停止所有轨道
                stream.getTracks().forEach(track => track.stop());
                console.log('已获得麦克风权限');
                return true;
            } catch (error) {
                console.error('获取麦克风权限失败:', error);
                updateStatus('无法访问麦克风，请在浏览器设置中允许访问', 'danger');
                alert('通话需要麦克风权限。请在浏览器设置中允许访问麦克风，然后重试。');
                return false;
            }
        }

        // 清理通话UI和资源
        function clearCallUI() {
            console.log('清理通话UI和资源');

            // 停止计时器
            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
                console.log('通话计时器已停止');
            }

            // 停止远程音频
            if (remoteAudio.srcObject) {
                try {
                    const tracks = remoteAudio.srcObject.getTracks();
                    tracks.forEach(track => {
                        track.stop();
                        console.log('远程音频轨道已停止');
                    });
                } catch (error) {
                    console.warn('停止远程音频轨道时出错:', error);
                } finally {
                    remoteAudio.srcObject = null;
                    console.log('远程音频源已清除');
                }
            }

            // 重置音频元素
            try {
                remoteAudio.pause();
                remoteAudio.currentTime = 0;
                remoteAudio.volume = 1.0; // 重置音量
                console.log('音频元素已重置');
            } catch (audioResetError) {
                console.warn('重置音频元素时出错:', audioResetError);
            }

            // 确保状态管理器重置到IDLE状态
            if (callStateManager) {
                callStateManager.resetToIdle();
                console.log('状态管理器已重置到IDLE');
            }

            // 重置UI - 让状态管理器处理按钮状态
            callInfo.classList.add('d-none');
            destinationInput.disabled = false;
            callTimer.textContent = '00:00';
            
            // 重新启用拨号盘和联系人列表
            document.querySelectorAll('.dialpad-btn').forEach(btn => {
                btn.disabled = false;
            });
            document.querySelectorAll('.contact-item').forEach(item => {
                item.disabled = false;
            });
            
            // 延迟更新状态，确保UI完全重置
            setTimeout(() => {
                updateStatus('就绪', 'success');
            }, 100);
            
            console.log('UI已重置');
        }

        // 更新状态显示
        function updateStatus(text, type) {
            statusDiv.textContent = text;
            statusAlert.className = `alert mb-4 alert-${type}`;
        }

        // 切换控制按钮状态
        function toggleControls(inCall) {
            callButton.disabled = inCall;
            if(!inCall) callButton.classList.remove('d-none');
            hangupButton.disabled = !inCall;
            destinationInput.disabled = inCall;

            // 在通话中时禁用拨号盘
            document.querySelectorAll('.dialpad-btn').forEach(btn => {
                btn.disabled = inCall;
            });

            // 在通话中时禁用联系人列表
            document.querySelectorAll('.contact-item').forEach(item => {
                item.disabled = inCall;
            });
        }

        // 显示或隐藏通话信息
        function showCallInfo(show) {
            if (show) {
                callInfo.classList.remove('d-none');
            } else {
                callInfo.classList.add('d-none');
            }
        }

        // 开始通话计时器
        function startCallTimer() {
            callStartTime = new Date();
            callTimer.textContent = "00:00";

            callTimerInterval = setInterval(() => {
                const now = new Date();
                const diff = new Date(now - callStartTime);
                const minutes = diff.getUTCMinutes().toString().padStart(2, '0');
                const seconds = diff.getUTCSeconds().toString().padStart(2, '0');
                callTimer.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        // 停止通话计时器
        function stopCallTimer() {
            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
            }
        }

        // 初始化页面
        updateStatus('正在初始化...', 'info');
        
        // Initialize call state manager
        callStateManager = new CallStateManager();
        
        initializeChecks().then(success => {
            if (success) {
                updateStatus('就绪', 'success');
                console.log('初始化检查完成，系统就绪');
            } else {
                console.warn('初始化检查失败，系统可能无法正常工作');
            }
        }).catch(error => {
            console.error('初始化检查过程中发生错误:', error);
            updateStatus('初始化失败: ' + error.message, 'danger');
        });
        
        // 拨号盘按钮事件
        document.querySelectorAll('.dialpad-btn').forEach(button => {
            button.addEventListener('click', () => {
                const key = button.getAttribute('data-key');
                destinationInput.value += key;
                destinationInput.focus();
            });
        });
        
        // 联系人列表点击事件
        document.querySelectorAll('.contact-item').forEach(item => {
            item.addEventListener('click', () => {
                const name = item.getAttribute('data-name');
                const phone = item.getAttribute('data-phone');
                
                destinationInput.value = phone;
                callerName.textContent = name;
                callerNumber.textContent = phone;
            });
        });
                       
        // 呼叫按钮点击事件
        callButton.addEventListener('click', async () => {
            const destination = destinationInput.value;
            if (!destination) {
                alert('请输入电话号码或选择联系人');
                return;
            }
                        
            try {
                console.log('开始呼叫:', destination);
                callStateManager.setState(CallState.OUTGOING);
                updateStatus('正在呼叫...', 'warning');
                const sdpOffer = await createPeerConnection(true, null);

                const response = await fetch('/api/phone/Call', {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({Destination: destination, Offer: sdpOffer })
                })

                callerName.innerHTML = destination;
            } catch (error) {
                console.error('呼叫失败:', error);
                let errorMessage = error.message;
                
                // 提供更友好的错误信息
                if (errorMessage.includes('JSON')) {
                    errorMessage = '服务器响应格式错误，请联系管理员';
                } else if (errorMessage.includes('WebRTC')) {
                    errorMessage = 'WebRTC连接失败，请检查网络连接或浏览器设置';
                } else if (errorMessage.includes('服务器错误')) {
                    errorMessage = '服务器处理请求失败，请稍后再试';
                }
                
                updateStatus(`呼叫失败: ${errorMessage}`, 'danger');
                callStateManager.resetToIdle();
                showCallInfo(false);
                
                // 显示错误提示
                alert(`呼叫失败: ${errorMessage}\n\n如果问题持续存在，请联系系统管理员。`);
            }
        });
        
        // 挂断按钮点击事件 - 使用新的挂断处理器
        hangupButton.addEventListener('click', async () => {
            if (hangupHandler) {
                await hangupHandler.initiateHangup('用户主动挂断');
            } else {
                // 回退到原有的挂断逻辑
                console.log('开始挂断通话');
                callStateManager.setState(CallState.ENDING);
                updateStatus('正在挂断...', 'warning');
                
                await fetch('/api/phone/Hangup', {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: null
                });                
            }
            callStateManager.resetToIdle();
            showCallInfo(false);
            updateStatus('已挂断...', 'success');
        });        

        // 接通电话
        answerButton.addEventListener('click', async () => { 
            updateStatus('正在接听...', 'warning');
            try{
                const answerSdp = await createPeerConnection(false, answerButton.attributes['data-offer']);
				console.log('接听SDP:', answerSdp);
                await signalRConnection.invoke("AnswerAsync", {caller: callerName.innerText, answerSdp: JSON.stringify(answerSdp)});

                updateStatus('接听成功', 'success');
                callStateManager.setState(CallState.CONNECTED);
                stopCallTimer();
                startCallTimer();
                showCallInfo(true);

                signalRConnection.invoke("GetSecureContextState").then(isSecure=>{
                    if(!isSecure){
                        updateStatus('当前连接不安全，通话质量可能受影响', 'warning');
                    }else{
                        updateStatus('安全链接通话中...', 'info');
                    }
                });
            }catch(error){ 
                updateStatus(`接听失败: ${error.message}`, 'danger');
                callStateManager.resetToIdle();
            }
        });
    </script>
}
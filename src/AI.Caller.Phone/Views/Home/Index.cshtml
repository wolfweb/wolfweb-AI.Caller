@using AI.Caller.Phone.Entities
@*
    For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
*@
@model IEnumerable<Contact>

@{
    ViewData["Title"] = "Phone";
}

<div class="container mt-4">
    <div class="row">
        <!-- 左侧通讯录 -->
        <div class="col-md-4">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">
                        <i class="bi bi-person-lines-fill"></i> 通讯录
                    </h5>
                </div>
                <div class="card-body p-0">
                    <div class="list-group list-group-flush" id="contactsList">
                        @if (Model != null && Model.Any())
                        {
                            @foreach (var contact in Model)
                            {
                                <button type="button" class="list-group-item list-group-item-action contact-item" 
                                        data-name="@contact.Name" data-phone="@contact.PhoneNumber">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div>
                                            <i class="bi bi-person-circle text-primary me-2"></i>
                                            <span class="contact-name">@contact.Name</span>
                                        </div>
                                        <span class="badge bg-light text-dark">@contact.PhoneNumber</span>
                                    </div>
                                </button>
                            }
                        }
                        else
                        {
                            <div class="list-group-item text-center text-muted py-4">
                                <i class="bi bi-info-circle"></i> 没有联系人
                                <div class="mt-2">
                                    <a asp-controller="Account" asp-action="AddContact" class="btn btn-sm btn-outline-primary">
                                        <i class="bi bi-plus-circle"></i> 添加联系人
                                    </a>
                                </div>
                            </div>
                        }
                    </div>
                </div>
                <div class="card-footer text-center">
                    <a asp-controller="Account" asp-action="ManageContacts" class="btn btn-outline-primary btn-sm">
                        <i class="bi bi-gear"></i> 管理通讯录
                    </a>
                </div>
            </div>
        </div>

        <!-- 右侧拨号器 -->
        <div class="col-md-8">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">
                        <i class="bi bi-telephone"></i> 拨号器
                    </h5>
                </div>
                <div class="card-body">
                    <!-- 音频元素 -->
                    <audio id="remoteAudio" autoplay class="d-none"></audio>
                    
                    <!-- 显示当前状态 -->
                    <div class="alert mb-4" id="statusAlert">
                        <span id="status">未连接</span>
                    </div>
                    
                    <!-- 录音状态指示器 -->
                    <div class="alert alert-info mb-4 d-none" id="recordingStatusAlert">
                        <div class="d-flex align-items-center">
                            <i class="bi bi-record-circle text-danger me-2" id="recordingIcon"></i>
                            <span id="recordingStatus">录音状态</span>
                            <span class="badge bg-secondary ms-auto" id="recordingTimer">00:00</span>
                        </div>
                    </div>
                    
                    <!-- 输入框和拨号按钮 -->
                    <div class="input-group mb-4">
                        <span class="input-group-text"><i class="bi bi-telephone"></i></span>
                        <input type="text" id="destination" class="form-control form-control-lg" 
                               placeholder="输入电话号码或选择联系人" />
                        <button id="callButton" class="btn btn-success">
                            <i class="bi bi-telephone-fill"></i> 拨打
                        </button>
                        <button id="answerButton" class="btn btn-primary d-none">
                            <i class="bi bi-telephone-inbound-fill"></i> 接听
                        </button>
                        <button id="hangupButton" class="btn btn-danger d-none">
                            <i class="bi bi-telephone-x-fill"></i> 挂断
                        </button>
                        <button id="startRecordingButton" class="btn btn-warning d-none">
                            <i class="bi bi-record-circle"></i> 开始录音
                        </button>
                        <button id="stopRecordingButton" class="btn btn-secondary d-none">
                            <i class="bi bi-stop-circle"></i> 停止录音
                        </button>
                    </div>
                    
                    <!-- 拨号盘 -->
                    <div class="dialpad mb-3">
                        <div class="row g-2 mb-2">
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="1">1</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="2">2</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="3">3</button></div>
                        </div>
                        <div class="row g-2 mb-2">
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="4">4</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="5">5</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="6">6</button></div>
                        </div>
                        <div class="row g-2 mb-2">
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="7">7</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="8">8</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="9">9</button></div>
                        </div>
                        <div class="row g-2">
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="*">*</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="0">0</button></div>
                            <div class="col-4"><button class="btn btn-light w-100 dialpad-btn" data-key="#">#</button></div>
                        </div>
                    </div>
                    
                    <!-- 通话信息 -->
                    <div class="call-info d-none" id="callInfo">
                        <div class="text-center mb-3">
                            <div class="display-1 text-primary">
                                <i class="bi bi-person-circle"></i>
                            </div>
                            <h3 id="callerName">未知联系人</h3>
                            <p id="callerNumber" class="text-muted"></p>
                        </div>
                        <div class="d-flex justify-content-center">
                            <div id="callTimer" class="badge bg-success p-2 fs-6">00:00</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <script src="~/js/ui-integration.js"></script>
    <script src="~/js/error-recovery.js"></script>
    <script src="~/js/hangup-handler.js"></script>
    <script src="~/js/integration-tests.js"></script>
    <script src="~/js/hangup-test.js"></script>
    <script>
        const destinationInput = document.getElementById('destination');
        const callButton = document.getElementById('callButton');
        const answerButton = document.getElementById('answerButton');
        const hangupButton = document.getElementById('hangupButton');
        const startRecordingButton = document.getElementById('startRecordingButton');
        const stopRecordingButton = document.getElementById('stopRecordingButton');
        const statusDiv = document.getElementById('status');
        const statusAlert = document.getElementById('statusAlert');
        const recordingStatusAlert = document.getElementById('recordingStatusAlert');
        const recordingStatus = document.getElementById('recordingStatus');
        const recordingTimer = document.getElementById('recordingTimer');
        const recordingIcon = document.getElementById('recordingIcon');
        const callerName = document.getElementById('callerName');
        const callerNumber = document.getElementById('callerNumber');
        const callInfo = document.getElementById('callInfo');
        const callTimer = document.getElementById('callTimer');
        const remoteAudio = document.getElementById('remoteAudio');
        let pc, localStream, signalRConnection, hangupHandler;
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let isRecording = false;
        let isAutoRecording = false;

        const CallState = {
            IDLE: 'IDLE',
            OUTGOING: 'OUTGOING',
            INCOMING: 'INCOMING',
            CONNECTED: 'CONNECTED',
            ENDING: 'ENDING'
        };

        const BUTTON_STATES = {
            IDLE: { call: true, answer: false, hangup: false, startRecording: false, stopRecording: false },
            OUTGOING: { call: false, answer: false, hangup: true, startRecording: false, stopRecording: false },
            INCOMING: { call: false, answer: true, hangup: false, startRecording: false, stopRecording: false },
            CONNECTED: { call: false, answer: false, hangup: true, startRecording: true, stopRecording: false },
            ENDING: { call: false, answer: false, hangup: false, startRecording: false, stopRecording: false }
        };

        class CallStateManager {
            constructor() {
                this.currentState = CallState.IDLE;
                this.isTransitioning = false;
                this.buttons = {
                    call: callButton,
                    answer: answerButton,
                    hangup: hangupButton,
                    startRecording: startRecordingButton,
                    stopRecording: stopRecordingButton
                };
                
                this.updateButtonVisibility();
                console.log('CallStateManager initialized in IDLE state');
            }

            setState(newState) {
                if (this.isTransitioning) {
                    console.warn(`State transition blocked: already transitioning from ${this.currentState}`);
                    return false;
                }

                if (!CallState[newState]) {
                    console.error(`Invalid state: ${newState}. Falling back to IDLE.`);
                    newState = CallState.IDLE;
                }

                const oldState = this.currentState;
                if (oldState === newState) {
                    console.log(`State unchanged: ${newState}`);
                    return true;
                }

                console.log(`State transition: ${oldState} → ${newState}`);
                
                this.isTransitioning = true;
                this.currentState = newState;
                
                try {
                    this.updateButtonVisibility();
                    console.log(`State successfully changed to: ${newState}`);
                    return true;
                } catch (error) {
                    console.error(`Error during state transition to ${newState}:`, error);
                    this.currentState = CallState.IDLE;
                    this.updateButtonVisibility();
                    return false;
                } finally {
                    this.isTransitioning = false;
                }
            }

            updateButtonVisibility() {
                const config = BUTTON_STATES[this.currentState];
                if (!config) {
                    console.error(`No button configuration for state: ${this.currentState}`);
                    return;
                }

                try {
                    if (this.buttons.call) {
                        if (config.call) {
                            this.showButton(this.buttons.call);
                        } else {
                            this.hideButton(this.buttons.call);
                        }
                    }

                    if (this.buttons.answer) {
                        if (config.answer) {
                            this.showButton(this.buttons.answer);
                        } else {
                            this.hideButton(this.buttons.answer);
                        }
                    }

                    if (this.buttons.hangup) {
                        if (config.hangup) {
                            this.showButton(this.buttons.hangup);
                        } else {
                            this.hideButton(this.buttons.hangup);
                        }
                    }

                    // 录音按钮的显示逻辑需要考虑当前录音状态
                    if (this.buttons.startRecording) {
                        if (config.startRecording && !isRecording) {
                            this.showButton(this.buttons.startRecording);
                        } else {
                            this.hideButton(this.buttons.startRecording);
                        }
                    }

                    if (this.buttons.stopRecording) {
                        if (isRecording) {
                            this.showButton(this.buttons.stopRecording);
                        } else {
                            this.hideButton(this.buttons.stopRecording);
                        }
                    }

                    console.log(`Button visibility updated for state: ${this.currentState}`, config);
                } catch (error) {
                    console.error('Error updating button visibility:', error);
                }
            }

            showButton(button) {
                if (!button) {
                    console.warn('Cannot show button: button element is null or undefined');
                    return;
                }
                try {
                    button.classList.remove('d-none');
                    button.disabled = false;
                } catch (error) {
                    console.error('Error showing button:', error);
                }
            }

            hideButton(button) {
                if (!button) {
                    console.warn('Cannot hide button: button element is null or undefined');
                    return;
                }
                try {
                    button.classList.add('d-none');
                    button.disabled = true;
                } catch (error) {
                    console.error('Error hiding button:', error);
                }
            }

            resetToIdle() {
                console.log('Resetting to IDLE state');
                this.setState(CallState.IDLE);
            }

            getCurrentState() {
                return this.currentState;
            }
        }

        let callStateManager;
        
        window.debugCallState = function() {
            console.log('=== 通话状态调试信息 ===');
            console.log('CallStateManager状态:', callStateManager ? callStateManager.getCurrentState() : '未初始化');
            console.log('拨号按钮状态:', {
                disabled: callButton.disabled,
                hidden: callButton.classList.contains('d-none'),
                classes: callButton.className
            });
            console.log('挂断按钮状态:', {
                disabled: hangupButton.disabled,
                hidden: hangupButton.classList.contains('d-none'),
                classes: hangupButton.className
            });
            console.log('接听按钮状态:', {
                disabled: answerButton.disabled,
                hidden: answerButton.classList.contains('d-none'),
                classes: answerButton.className
            });
            console.log('输入框状态:', {
                disabled: destinationInput.disabled,
                value: destinationInput.value
            });
            console.log('HangupHandler状态:', window.hangupHandler ? {
                isHangingUp: window.hangupHandler.isCurrentlyHangingUp()
            } : '未初始化');
            console.log('=== 调试信息结束 ===');
        };

        window.testCallStateManager = {
            testIdleState: function() {
                console.log('Testing IDLE state...');
                callStateManager.setState(CallState.IDLE);
                const callVisible = !callButton.classList.contains('d-none');
                const answerHidden = answerButton.classList.contains('d-none');
                const hangupHidden = hangupButton.classList.contains('d-none');
                console.log(`IDLE state test: Call visible: ${callVisible}, Answer hidden: ${answerHidden}, Hangup hidden: ${hangupHidden}`);
                return callVisible && answerHidden && hangupHidden;
            },
            
            testOutgoingState: function() {
                console.log('Testing OUTGOING state...');
                callStateManager.setState(CallState.OUTGOING);
                const callHidden = callButton.classList.contains('d-none');
                const answerHidden = answerButton.classList.contains('d-none');
                const hangupVisible = !hangupButton.classList.contains('d-none');
                console.log(`OUTGOING state test: Call hidden: ${callHidden}, Answer hidden: ${answerHidden}, Hangup visible: ${hangupVisible}`);
                return callHidden && answerHidden && hangupVisible;
            },
            
            testIncomingState: function() {
                console.log('Testing INCOMING state...');
                callStateManager.setState(CallState.INCOMING);
                const callHidden = callButton.classList.contains('d-none');
                const answerVisible = !answerButton.classList.contains('d-none');
                const hangupHidden = hangupButton.classList.contains('d-none');
                console.log(`INCOMING state test: Call hidden: ${callHidden}, Answer visible: ${answerVisible}, Hangup hidden: ${hangupHidden}`);
                return callHidden && answerVisible && hangupHidden;
            },
            
            testConnectedState: function() {
                console.log('Testing CONNECTED state...');
                callStateManager.setState(CallState.CONNECTED);
                const callHidden = callButton.classList.contains('d-none');
                const answerHidden = answerButton.classList.contains('d-none');
                const hangupVisible = !hangupButton.classList.contains('d-none');
                console.log(`CONNECTED state test: Call hidden: ${callHidden}, Answer hidden: ${answerHidden}, Hangup visible: ${hangupVisible}`);
                return callHidden && answerHidden && hangupVisible;
            },
            
            testAllStates: function() {
                console.log('Running all state tests...');
                const results = {
                    idle: this.testIdleState(),
                    outgoing: this.testOutgoingState(),
                    incoming: this.testIncomingState(),
                    connected: this.testConnectedState()
                };
                
                const allPassed = Object.values(results).every(result => result);
                console.log('Test results:', results);
                console.log(`All tests ${allPassed ? 'PASSED' : 'FAILED'}`);
                
                callStateManager.setState(CallState.IDLE);
                return results;
            },
            
            getCurrentState: function() {
                return callStateManager.getCurrentState();
            }
        };

        let iceServers = [{ urls: 'stun:stun.l.google.com:19302' }]; // Default fallback
        let iceTransportPolicy = 'all';
        let callTimerInterval;
        let callStartTime;
        
        async function fetchIceServers() {
            try {
                const response = await fetch('/api/WebRTC/ice-servers');
                if (response.ok) {
                    const config = await response.json();
                    console.log('Fetched ICE server configuration:', config);
                    
                    if (config.iceServers && config.iceServers.length > 0) {
                        iceServers = config.iceServers;
                        console.log(`Using ${iceServers.length} ICE servers from server configuration`);
                    }
                    
                    if (config.iceTransportPolicy) {
                        iceTransportPolicy = config.iceTransportPolicy;
                        console.log(`Using ICE transport policy: ${iceTransportPolicy}`);
                    }
                    
                    return true;
                } else {
                    console.error('Failed to fetch ICE server configuration:', response.status, response.statusText);
                    return false;
                }
            } catch (error) {
                console.error('Error fetching ICE server configuration:', error);
                return false;
            }
        }
        
        signalRConnection = new signalR.HubConnectionBuilder()        
        .withUrl("/webrtc")
		.configureLogging(signalR.LogLevel.Debug)
        .build();

        signalRConnection.on("inCalling", function(x){
            console.log("Incoming call received:", x);
            callerName.innerHTML = x.caller;
            callStateManager.setState(CallState.INCOMING);
            
            try {
                let offerObj;
                if (typeof x.offerSdp === 'string') {
                    offerObj = JSON.parse(x.offerSdp);
                } else if (typeof x.offerSdp === 'object') {
                    offerObj = x.offerSdp;
                } else {
                    console.error("Invalid offer SDP type:", typeof x.offerSdp);
                    updateStatus('来电数据格式错误', 'danger');
                    return;
                }
                
                answerButton.attributes['data-offer'] = offerObj;
                console.log("Offer SDP processed:", offerObj);
            } catch (parseError) {
                console.error("Error parsing offer SDP:", parseError);
                console.error("Original offer data:", x.offerSdp);
                updateStatus('来电数据解析失败', 'danger');
                return;
            }
            
            showCallInfo(true);
            startCallTimer();
        });

        signalRConnection.on("callAnswered", async function(){
            try {
                updateStatus('接听成功', 'success');
                callStateManager.setState(CallState.CONNECTED);
                stopCallTimer();
                startCallTimer();
                showCallInfo(true);

                signalRConnection.invoke("GetSecureContextState").then(isSecure=>{
                    if(!isSecure){
                        updateStatus('当前连接不安全，通话质量可能受影响', 'warning');
                    }else{
                        updateStatus('安全链接通话中...', 'info');
                    }
                });
            } catch (parseError) {
                console.error("Error parsing offer SDP:", parseError);
                console.error("Original offer data:", x.offerSdp);
                updateStatus('来电数据解析失败', 'danger');
                return;
            }
        });

        signalRConnection.on("answered", function(){
            updateStatus('通话已接听', 'success');
            callStateManager.setState(CallState.CONNECTED);
            showCallInfo(false);
            stopCallTimer();
            startCallTimer();
            showCallInfo(true);

            signalRConnection.invoke("GetSecureContextState").then(isSecure=>{
                if(!isSecure){
                    updateStatus('当前连接不安全，通话质量可能受影响', 'warning');
                }else{
                    updateStatus('安全链接通话中...', 'info');
                }
            });
        });

        signalRConnection.on("callTimeout", function(){
            updateStatus('拨打超时', 'warning');
            callStateManager.resetToIdle();
            showCallInfo(false);
            stopCallTimer();
        });

        signalRConnection.on("sdpAnswered", function(answerDesc){
            console.log("SDP Answer received from server:", answerDesc, "Type:", typeof answerDesc);
            if (pc) {
                try {
                    let sdpObj;
                    if (typeof answerDesc === 'string') {
                        sdpObj = JSON.parse(answerDesc);
                    } else if (typeof answerDesc === 'object') {
                        sdpObj = answerDesc;
                    } else {
                        console.error("Invalid SDP answer type:", typeof answerDesc);
                        return;
                    }
                    
                    console.log("Processing SDP answer:", sdpObj);
                    
                    pc.setRemoteDescription(sdpObj).then(() => {
                        console.log("Remote description set successfully");
                    }).catch(error => {
                        console.error("Error setting remote description:", error);
                        console.error("SDP data:", sdpObj);
                    });
                } catch (parseError) {
                    console.error("Error parsing SDP answer:", parseError);
                    console.error("Original SDP data:", answerDesc);
                }
			}
        });

        signalRConnection.on("receiveIceCandidate",function(candidate){
            if (pc && candidate) {
                console.log("Adding ICE candidate from server:", candidate, pc);
                pc.addIceCandidate(typeof candidate == "string" ? JSON.parse(candidate) : candidate).then(()=>{
                    console.log("add IceCandidate successfully");
                }).catch(error=>{
                    console.error("Error add IceCandidate", error);
                });
            }
        });

        window.addEventListener('online', () => {
            updateStatus('网络已恢复连接', 'success');
            setTimeout(() => {
                updateStatus('就绪', 'success');
            }, 3000);
        });
        
        window.addEventListener('offline', () => { 
            updateStatus('网络已断开，通话可能受到影响', 'danger');
            if (callStateManager) {
                callStateManager.resetToIdle();
            }
        });
                
        window.addEventListener('beforeunload', (event) => {
            //todo: 
        });
                
        function checkWebRTCSupport() {
            if (!window.RTCPeerConnection) {
                updateStatus('您的浏览器不支持WebRTC，请使用Chrome、Firefox、Edge或Safari的最新版本', 'danger');
                callButton.disabled = true;
                return false;
            }
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateStatus('您的浏览器可能不完全支持音频功能，通话质量可能受影响', 'warning');
            }
            
            return true;
        }
        
        function checkNetworkConnection() {
            if (!navigator.onLine) {
                updateStatus('网络连接不可用，请检查您的网络设置', 'danger');
                return false;
            }
            return true;
        }
        
        async function createPeerConnection(isCaller, remoteSdp) { 
            const rtcConfig = {
                iceServers: iceServers,
                iceTransportPolicy: iceTransportPolicy
            };
            
            console.log('Creating RTCPeerConnection with config:', rtcConfig);
            pc = new RTCPeerConnection(rtcConfig);
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            pc.ontrack = evt => remoteAudio.srcObject = evt.streams[0];

            pc.onicecandidate = async evt => {
                if (evt.candidate) {
                    console.log("新ICE候选者:", evt.candidate);
                    try {
                        // 发送ICE候选者对象（不需要JSON.stringify，SignalR会自动处理）
                        await signalRConnection.invoke("SendIceCandidateAsync", evt.candidate);
                        console.log("ICE候选者发送成功");
                    } catch (error) {
                        console.error("发送ICE候选者失败:", error);
                    }
                } 
            };

            pc.onicegatheringstatechange = () => console.log("onicegatheringstatechange: " + pc.iceGatheringState);
            pc.oniceconnectionstatechange = () => console.log("oniceconnectionstatechange: " + pc.iceConnectionState);
            pc.onsignalingstatechange = () => console.log("onsignalingstatechange: " + pc.signalingState);
            pc.onconnectionstatechange = () => console.log("onconnectionstatechange: " + pc.connectionState);

            if(isCaller){
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                return pc.localDescription;
            }else{
                await pc.setRemoteDescription(remoteSdp);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                return pc.localDescription;
            }            
        }

        async function selectOptimalAudioDevices() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                return false;
            }
            
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                console.log(`找到 ${audioInputDevices.length} 个麦克风设备`);
                
                const audioOutputDevices = devices.filter(device => device.kind === 'audiooutput');
                console.log(`找到 ${audioOutputDevices.length} 个扬声器设备`);
                
                let preferredMicrophoneId = '';
                if (audioInputDevices.length > 1) {
                    const nonDefaultMicrophone = audioInputDevices.find(device => 
                        !device.deviceId.includes('default') && 
                        !device.label.toLowerCase().includes('default'));
                    
                    if (nonDefaultMicrophone) {
                        preferredMicrophoneId = nonDefaultMicrophone.deviceId;
                        console.log('选择非默认麦克风:', nonDefaultMicrophone.label);
                    }
                } else if (audioInputDevices.length === 1) {
                    preferredMicrophoneId = audioInputDevices[0].deviceId;
                    console.log('使用唯一可用麦克风:', audioInputDevices[0].label || '未命名设备');
                }
                
                let preferredSpeakerId = '';
                if (audioOutputDevices.length > 1) {
                    const nonDefaultSpeaker = audioOutputDevices.find(device => 
                        !device.deviceId.includes('default') && 
                        !device.label.toLowerCase().includes('default'));
                    
                    if (nonDefaultSpeaker) {
                        preferredSpeakerId = nonDefaultSpeaker.deviceId;
                        console.log('选择非默认扬声器:', nonDefaultSpeaker.label);
                    }
                } else if (audioOutputDevices.length === 1) {
                    preferredSpeakerId = audioOutputDevices[0].deviceId;
                    console.log('使用唯一可用扬声器:', audioOutputDevices[0].label || '未命名设备');
                }
                
                if (preferredSpeakerId && typeof remoteAudio.setSinkId === 'function') {
                    try {
                        await remoteAudio.setSinkId(preferredSpeakerId);
                        console.log('已设置音频输出设备');
                    } catch (sinkIdError) {
                        console.warn('设置音频输出设备失败:', sinkIdError);
                    }
                }
                
                return {
                    preferredMicrophoneId,
                    preferredSpeakerId,
                    audioInputDevices,
                    audioOutputDevices
                };
            } catch (error) {
                console.error('枚举音频设备失败:', error);
                return false;
            }
        }
        
        async function initializeChecks() {
            if (!checkWebRTCSupport()) {
                return false;
            }
            
            await fetchIceServers();
            
            if (!checkNetworkConnection()) {
                return false;
            }
            try {
                const hasPermission = await checkMicrophonePermission();
                if (!hasPermission) {
                    updateStatus('未获得麦克风权限，通话功能可能受限', 'warning');
                } else {
                    const deviceInfo = await selectOptimalAudioDevices();
                    if (deviceInfo) {
                        window.preferredAudioDevices = deviceInfo;
                    }
                }
            } catch (error) {
                updateStatus('无法检查麦克风权限，通话功能可能受限', 'warning');
            }
            setupGlobalErrorHandling();

            await signalRConnection.start();
            
            const uiElements = {
                hangupButton: hangupButton,
                statusAlert: statusAlert,
                callInfo: callInfo,
                updateStatus: updateStatus,
                showCallInfo: showCallInfo,
                clearCallUI: clearCallUI
            };
            
            hangupHandler = new HangupHandler(signalRConnection, uiElements, callStateManager);
            
            document.addEventListener('callEnded', (event) => {
                console.log('收到通话结束事件:', event.detail);
                showCallInfo(false);
                stopCallTimer();
                console.log('通话结束事件处理完成');
            });
            
            document.addEventListener('remoteHangup', (event) => {
                console.log('收到对方挂断事件:', event.detail);
                showCallInfo(false);
                stopCallTimer();
                console.log('对方挂断事件处理完成');
            });

            localStream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
            
            return true;
        }
        
        function setupGlobalErrorHandling() {
            window.addEventListener('error', (event) => {
                console.error('未捕获的错误:', event.error || event.message);
                event.preventDefault();
                return true;
            });
            
            window.addEventListener('unhandledrejection', (event) => {
                console.error('未处理的Promise拒绝:', event.reason);
                event.preventDefault();
                return true;
            });
            
            if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) {
                navigator.mediaDevices.addEventListener('devicechange', handleDeviceChange);
                console.log('设备变化监听已设置');
            }
            
            console.log('全局错误处理已设置');
        }
        
        async function handleDeviceChange() {
            console.log('检测到媒体设备变化');
            
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                const audioOutputDevices = devices.filter(device => device.kind === 'audiooutput');
                
                console.log('可用音频输入设备:', audioInputDevices.length);
                console.log('可用音频输出设备:', audioOutputDevices.length);                
            } catch (error) {
                console.error('获取媒体设备信息时出错:', error);
            }
        }

        async function checkMicrophonePermission() {
            try {
                console.log('检查麦克风权限');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                console.log('已获得麦克风权限');
                return true;
            } catch (error) {
                console.error('获取麦克风权限失败:', error);
                updateStatus('无法访问麦克风，请在浏览器设置中允许访问', 'danger');
                alert('通话需要麦克风权限。请在浏览器设置中允许访问麦克风，然后重试。');
                return false;
            }
        }

        function clearCallUI() {
            console.log('清理通话UI和资源');

            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
                console.log('通话计时器已停止');
            }

            if (remoteAudio.srcObject) {
                try {
                    const tracks = remoteAudio.srcObject.getTracks();
                    tracks.forEach(track => {
                        track.stop();
                        console.log('远程音频轨道已停止');
                    });
                } catch (error) {
                    console.warn('停止远程音频轨道时出错:', error);
                } finally {
                    remoteAudio.srcObject = null;
                    console.log('远程音频源已清除');
                }
            }

            try {
                remoteAudio.pause();
                remoteAudio.currentTime = 0;
                remoteAudio.volume = 1.0; // 重置音量
                console.log('音频元素已重置');
            } catch (audioResetError) {
                console.warn('重置音频元素时出错:', audioResetError);
            }
            if (callStateManager) {
                callStateManager.resetToIdle();
                console.log('状态管理器已重置到IDLE');
            }

            callInfo.classList.add('d-none');
            destinationInput.disabled = false;
            callTimer.textContent = '00:00';
            
            document.querySelectorAll('.dialpad-btn').forEach(btn => {
                btn.disabled = false;
            });
            document.querySelectorAll('.contact-item').forEach(item => {
                item.disabled = false;
            });
            
            setTimeout(() => {
                updateStatus('就绪', 'success');
            }, 100);
            
            console.log('UI已重置');
        }

        function updateStatus(text, type) {
            statusDiv.textContent = text;
            statusAlert.className = `alert mb-4 alert-${type}`;
        }

        function toggleControls(inCall) {
            callButton.disabled = inCall;
            if(!inCall) callButton.classList.remove('d-none');
            hangupButton.disabled = !inCall;
            destinationInput.disabled = inCall;

            document.querySelectorAll('.dialpad-btn').forEach(btn => {
                btn.disabled = inCall;
            });

            document.querySelectorAll('.contact-item').forEach(item => {
                item.disabled = inCall;
            });
        }

        function showCallInfo(show) {
            if (show) {
                callInfo.classList.remove('d-none');
            } else {
                callInfo.classList.add('d-none');
            }
        }

        function startCallTimer() {
            callStartTime = new Date();
            callTimer.textContent = "00:00";

            callTimerInterval = setInterval(() => {
                const now = new Date();
                const diff = new Date(now - callStartTime);
                const minutes = diff.getUTCMinutes().toString().padStart(2, '0');
                const seconds = diff.getUTCSeconds().toString().padStart(2, '0');
                callTimer.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopCallTimer() {
            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
            }
        }

        updateStatus('正在初始化...', 'info');
        
        callStateManager = new CallStateManager();
        
        initializeChecks().then(success => {
            if (success) {
                updateStatus('就绪', 'success');
                console.log('初始化检查完成，系统就绪');
            } else {
                console.warn('初始化检查失败，系统可能无法正常工作');
            }
        }).catch(error => {
            console.error('初始化检查过程中发生错误:', error);
            updateStatus('初始化失败: ' + error.message, 'danger');
        });
        
        document.querySelectorAll('.dialpad-btn').forEach(button => {
            button.addEventListener('click', () => {
                const key = button.getAttribute('data-key');
                destinationInput.value += key;
                destinationInput.focus();
            });
        });
        
        document.querySelectorAll('.contact-item').forEach(item => {
            item.addEventListener('click', () => {
                const name = item.getAttribute('data-name');
                const phone = item.getAttribute('data-phone');
                
                destinationInput.value = phone;
                callerName.textContent = name;
                callerNumber.textContent = phone;
            });
        });
                       
        callButton.addEventListener('click', async () => {
            const destination = destinationInput.value;
            if (!destination) {
                alert('请输入电话号码或选择联系人');
                return;
            }
                        
            try {
                console.log('开始呼叫:', destination);
                callStateManager.setState(CallState.OUTGOING);
                updateStatus('正在呼叫...', 'warning');
                const sdpOffer = await createPeerConnection(true, null);

                const response = await fetch('/api/phone/Call', {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({Destination: destination, Offer: sdpOffer })
                })

                callerName.innerHTML = destination;
            } catch (error) {
                console.error('呼叫失败:', error);
                let errorMessage = error.message;
                
                if (errorMessage.includes('JSON')) {
                    errorMessage = '服务器响应格式错误，请联系管理员';
                } else if (errorMessage.includes('WebRTC')) {
                    errorMessage = 'WebRTC连接失败，请检查网络连接或浏览器设置';
                } else if (errorMessage.includes('服务器错误')) {
                    errorMessage = '服务器处理请求失败，请稍后再试';
                }
                
                updateStatus(`呼叫失败: ${errorMessage}`, 'danger');
                callStateManager.resetToIdle();
                showCallInfo(false);
            }
        });
        
        hangupButton.addEventListener('click', async () => {
            if (hangupHandler) {
                await hangupHandler.initiateHangup('用户主动挂断');
            } else {
                console.log('开始挂断通话');
                callStateManager.setState(CallState.ENDING);
                updateStatus('正在挂断...', 'warning');
                
                await fetch('/api/phone/Hangup', {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: null
                });                
            }
            callStateManager.resetToIdle();
            showCallInfo(false);
            updateStatus('已挂断...', 'success');
        });        

        answerButton.addEventListener('click', async () => { 
            updateStatus('正在接听...', 'warning');
            try{
                const answerSdp = await createPeerConnection(false, answerButton.attributes['data-offer']);
				console.log('接听SDP:', answerSdp);
                await signalRConnection.invoke("AnswerAsync", {caller: callerName.innerText, answerSdp: JSON.stringify(answerSdp)});

                updateStatus('接听成功', 'success');
                callStateManager.setState(CallState.CONNECTED);
                stopCallTimer();
                startCallTimer();
                showCallInfo(true);

                signalRConnection.invoke("GetSecureContextState").then(isSecure=>{
                    if(!isSecure){
                        updateStatus('当前连接不安全，通话质量可能受影响', 'warning');
                    }else{
                        updateStatus('安全链接通话中...', 'info');
                    }
                });
            }catch(error){ 
                updateStatus(`接听失败: ${error.message}`, 'danger');
                callStateManager.resetToIdle();
            }
        });

        // 录音控制功能
        startRecordingButton.addEventListener('click', async () => {
            try {
                console.log('手动开始录音');
                updateRecordingStatus('正在开始录音...', 'warning');
                
                // 检查SignalR连接状态
                if (signalRConnection.state !== signalR.HubConnectionState.Connected) {
                    console.error('SignalR连接未建立，当前状态:', signalRConnection.state);
                    updateRecordingStatus('连接未建立，无法开始录音', 'danger');
                    return;
                }
                
                const calleeNumber = destinationInput.value || callerNumber.textContent || '未知';
                console.log('调用StartRecordingAsync，参数:', calleeNumber);
                
                const result = await signalRConnection.invoke("StartRecordingAsync", calleeNumber);
                console.log('StartRecordingAsync返回结果:', result);
                
                if (result && result.success) {
                    console.log('录音开始成功:', result);
                    updateRecordingStatus('录音已开始', 'success');
                } else {
                    console.error('录音开始失败:', result);
                    updateRecordingStatus('录音开始失败: ' + (result?.message || '未知错误'), 'danger');
                }
            } catch (error) {
                console.error('开始录音时发生错误:', error);
                console.error('错误详情:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                updateRecordingStatus('录音开始失败: ' + error.message, 'danger');
            }
        });

        stopRecordingButton.addEventListener('click', async () => {
            try {
                console.log('手动停止录音');
                updateRecordingStatus('正在停止录音...', 'warning');
                
                // 检查SignalR连接状态
                if (signalRConnection.state !== signalR.HubConnectionState.Connected) {
                    console.error('SignalR连接未建立，当前状态:', signalRConnection.state);
                    updateRecordingStatus('连接未建立，无法停止录音', 'danger');
                    return;
                }
                
                console.log('调用StopRecordingAsync');
                const result = await signalRConnection.invoke("StopRecordingAsync");
                console.log('StopRecordingAsync返回结果:', result);
                
                if (result && result.success) {
                    console.log('录音停止成功:', result);
                    updateRecordingStatus('录音已停止', 'success');
                } else {
                    console.error('录音停止失败:', result);
                    updateRecordingStatus('录音停止失败: ' + (result?.message || '未知错误'), 'danger');
                }
            } catch (error) {
                console.error('停止录音时发生错误:', error);
                console.error('错误详情:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                updateRecordingStatus('录音停止失败: ' + error.message, 'danger');
            }
        });

        // 录音状态更新函数
        function updateRecordingStatus(message, type = 'info') {
            recordingStatus.textContent = message;
            recordingStatusAlert.className = `alert alert-${type} mb-4`;
            
            if (type === 'danger') {
                recordingStatusAlert.classList.remove('d-none');
                setTimeout(() => {
                    recordingStatusAlert.classList.add('d-none');
                }, 5000);
            }
        }

        // 录音计时器功能
        function startRecordingTimer() {
            recordingStartTime = new Date();
            recordingTimer.textContent = "00:00";
            recordingIcon.className = "bi bi-record-circle text-danger me-2";

            recordingTimerInterval = setInterval(() => {
                const now = new Date();
                const diff = new Date(now - recordingStartTime);
                const minutes = diff.getUTCMinutes().toString().padStart(2, '0');
                const seconds = diff.getUTCSeconds().toString().padStart(2, '0');
                recordingTimer.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopRecordingTimer() {
            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }
            recordingIcon.className = "bi bi-stop-circle text-secondary me-2";
        }

        // SignalR 录音事件处理
        signalRConnection.on("recordingStarted", function(data) {
            console.log("录音已开始:", data);
            isRecording = true;
            isAutoRecording = data.isAuto || false;
            
            updateRecordingStatus(isAutoRecording ? '自动录音已开始' : '手动录音已开始', 'success');
            recordingStatusAlert.classList.remove('d-none');
            
            startRecordingTimer();
            callStateManager.updateButtonVisibility();
        });

        signalRConnection.on("recordingStopped", function(data) {
            console.log("录音已停止:", data);
            isRecording = false;
            
            updateRecordingStatus('录音已停止并保存', 'info');
            setTimeout(() => {
                recordingStatusAlert.classList.add('d-none');
            }, 3000);
            
            stopRecordingTimer();
            callStateManager.updateButtonVisibility();
        });

        signalRConnection.on("recordingError", function(data) {
            console.error("录音错误:", data);
            isRecording = false;
            
            updateRecordingStatus('录音错误: ' + data.message, 'danger');
            stopRecordingTimer();
            callStateManager.updateButtonVisibility();
        });

        signalRConnection.on("recordingStatusUpdate", function(data) {
            console.log("录音状态更新:", data);
            if (data.status) {
                const statusText = data.status === 'Recording' ? '录音中' : 
                                 data.status === 'Completed' ? '录音完成' : 
                                 data.status === 'Failed' ? '录音失败' : data.status;
                updateRecordingStatus(statusText, data.status === 'Failed' ? 'danger' : 'info');
            }
        });

        // 在通话状态变化时更新录音按钮
        const originalSetState = callStateManager.setState;
        callStateManager.setState = function(newState) {
            const result = originalSetState.call(this, newState);
            
            // 当通话结束时，自动停止录音计时器显示
            if (newState === CallState.IDLE && isRecording) {
                // 不改变录音状态，只是隐藏录音状态显示
                setTimeout(() => {
                    if (!isRecording) {
                        recordingStatusAlert.classList.add('d-none');
                    }
                }, 5000);
            }
            
            return result;
        };

        console.log('录音控制功能已初始化');
    </script>
}